---
title: "PMI rat VH - Normalization and PCA"
author: "IMML"
date: " updated : `r Sys.time()`"
output: 
  html_document:
    code_folding: hide
    theme: cosmo
    toc: yes
editor_options: 
  chunk_output_type: console
---
Data used in this script is sent through XCMS on the cluster together with the samples from the remaining three tissue types WITHOUT any grouping .
```{r, message=F, warning=F}

# Initialization

## Turning off warnings and messages in output

knitr::opts_chunk$set(message=F)
knitr::opts_chunk$set(warning=F)

## Loading required packages
library(tidyverse)
library(cowplot)
library(ggsci)
library(Hmisc)
library(dplyr)
library(xlsx)
library(ggfortify)

## Configuration of output format etc.

options(digits = 5)        # number of digits printed by R default (vectors, data.frames, lists)
options(pillar.sigfig = 5) # number of digits printed by tibbles default.

text_base_size   <- 8   # in pt
fig.witdh        <- 200  # in mm
fig.height       <- 150  # in mm

# Set all text in plots to same size
theme_set(theme_cowplot(font_size = text_base_size, rel_small = 1, rel_tiny = 1, rel_large = 1))

# Setting output sizes for plots
knitr::opts_chunk$set(fig.width = fig.witdh/25.4)
knitr::opts_chunk$set(fig.height = fig.height/25.4)
knitr::opts_chunk$set(dpi = 108) # You need to find your minotors dpi yourself.

# Setting text size inside plots (geom_text, geom_label etc.)
ggplot_text_size <- text_base_size / ggplot2::.pt
# Now use: geom_text(..., size = ggplot_text_size)

# For saving plots!
# Use: ggsave(plot1, filename="myplot.png", width = fig.witdh, height=fig.height, units = "mm")
# Use: ggsave(plot1, filename="myplot.pdf", width = fig.witdh, height=fig.height, units = "mm")

# Changing default ggplot colours
# see ?scale_fill_continuous
options(ggplot2.continuous.fill  = scale_fill_viridis_c)    
options(ggplot2.discrete.fill    = list(ggsci::pal_locuszoom()(7)) )
options(ggplot2.continuous.colour = scale_colour_viridis_c)
options(ggplot2.discrete.colour   = list(ggsci::pal_locuszoom()(7)))

## Set locale if you want Danish/English month names etc.

#x <- Sys.setlocale(locale = "Danish_Denmark")  # For Danish axes on plot
x <- Sys.setlocale(locale = "English_Denmark")  # For English axes on plot
rm(x)

source("...\Functions_R\\pca_function.R")

source("...\Functions_R\\PCA_replicate_function_PMI_IMML.R")

source("...\Functions_R\\PCA_replicate_function_IMML.R")

source("...\Functions_R\\PCA_replicate_function_raw_PMI_IMML.R")

```

# Load Data  
  
```{r load data}

setwd("...")

#Loading and formatting:
Raw_data <- readxl::read_xlsx(path = "./PMI_rat_VH_raw_winfo_filtered_blank_pos.xlsx")

Raw_data <- t(Raw_data)

colnames(Raw_data) <- Raw_data[1,]

Raw_data <- Raw_data[-c(1, 46, 47, 48),]%>%
  as.data.frame()


Raw_data <- tibble::rownames_to_column(Raw_data, "Info")
CAMERA_info <- Raw_data[1:13,]


Prep_data <- Raw_data[14:nrow(Raw_data),]

#making a more useful dataframe
ms <- list()

ms$rowinfo <- Prep_data%>%
  select(Info, Sample_ID, Unique_ID, Tissue_ID, Rat_ID, Batch, Type, PMI, Death_manner, Room_Temperature, Sampling_order, Time_since_death_h)%>%
  rowid_to_column()

ms$values <- Prep_data %>%
  select(-Info, -Sample_ID, -Unique_ID, -Tissue_ID, -Rat_ID, -Batch, -Type, -PMI, -Death_manner, -Room_Temperature, -Sampling_order, -Time_since_death_h)%>%
  as.matrix()


storage.mode(ms$values) <- "numeric"
ms$values <- replace(ms$values, is.na(ms$values), 0)


ms$rowinfo$Time_since_death_h <- round(as.numeric(ms$rowinfo$Time_since_death_h), digits = 0)

#1. step normalization is removal of constant features with variation=0:
constant_columns <-
  ms$values %>%
  as_tibble() %>%
  map_lgl(~var(.x)==0) #finds if variance=0 by searching each column

#We will remove:
constant_columns[constant_columns]
# No constant columns

ms$values <- ms$values[,!constant_columns]
```

# PCA of raw data
```{r PCA plots raw}

tmp1 <- ms$rowinfo %>% mutate(color_variable= Time_since_death_h)
tmp2 <- ms$values

plot_pmi_pca_replicates(tmp1,tmp2, title = "All VH samples, all raw features", show_legend_title = "Time since death (h)")
```

```{r histogram}

#plot histogram
pd <- as.data.frame(ms$values) %>% 
  pivot_longer(cols = everything(), values_to = "raw") %>%
  select(-name) %>%
  pivot_longer(cols = everything()) %>%
  mutate(name = fct_inorder(name))

ggplot(pd, aes(x=value, fill=name)) + 
  geom_histogram() +
  facet_wrap(~name, scales = "free", ncol=1) +
  ggtitle("Distrubution of raw data") +
  theme(legend.position = "none", axis.title = element_blank())

```


# Normalization
```{r Normalization}

#Normalization:


#2. step - Normalization by taking the peaks in the middle 50% and use the sum to normalize. 

target_values <- ms$values %>% as.data.frame()

target_values2 <- target_values

target_values3 <- as.matrix(target_values)
target_values3 <- unname(target_values3)

median_peak <- median(target_values3)

for(i in 1:nrow(target_values3)) {
 x <- target_values3[i,]
 j <- x > quantile(x, 0.25) & x < quantile(x,0.75)
 mysum <- sum(x[j])
 target_values2[i,] <- median_peak  * x /mysum

}


ms$values <- target_values2


#3. transform data:
#histogram before transformation:
#pd <- as.data.frame(ms$good_single_compounds) %>% 
#  pivot_longer(cols = everything(), values_to = "raw") %>%
#  mutate(log1p = log1p(raw)) %>%
#  mutate(`4th root` = raw^(1/4)) %>%
#  select(-name) %>%
#  pivot_longer(cols = everything()) %>%
#  mutate(name = fct_inorder(name))

#ggplot(pd, aes(x=value, fill=name)) + 
#  geom_histogram() +
#  facet_wrap(~name, scales = "free", ncol=1) +
#  ggtitle("Effect of transformation") +
#  theme(legend.position = "none", axis.title = element_blank())


#Transform values
#ms$good_single_compounds <- log1p(ms$good_single_compounds)


#cleaning
#rm(pd, r, target_values, target_values2, target_values3, constant_columns, i, j, median_peak, mysum, x)



#4. Batch normalization:
#new feature value = (feature value - mean feature value in batch)/std. of feature in batch

Batch1_features <- ms$rowinfo%>%
  cbind(ms$values)%>%
  filter(Batch == "1")

Batch1_metadata <- Batch1_features[,1:13]
Batch1_features <- Batch1_features[,14:ncol(Batch1_features)]
  
Batch1_norm_features <- Batch1_features%>%
  as.data.frame()

  
for (col in 1:ncol(Batch1_features)){
  for (row in 1:nrow(Batch1_features)){
    Batch1_norm_features[row, col] <- (Batch1_features[row, col] - mean(Batch1_features[, col]))/sd(Batch1_features[, col])
  }  
}  
  
  
Batchnorm <- Batch1_metadata%>%
  cbind(Batch1_norm_features)


ms$rowinfo <- Batchnorm[,1:13]
ms$values <- Batchnorm[,14:ncol(Batchnorm)]

rm(Batch1_features, Batch1_metadata, Batch1_norm_features, Batchnorm, col, row)



#plot histogram
pd <- as.data.frame(ms$values) %>% 
  pivot_longer(cols = everything(), values_to = "norm, batchnorm") %>%
  select(-name) %>%
  pivot_longer(cols = everything()) %>%
  mutate(name = fct_inorder(name))

ggplot(pd, aes(x=value, fill=name)) + 
  geom_histogram() +
  facet_wrap(~name, scales = "free", ncol=1) +
  ggtitle("Effect of normalization") +
  theme(legend.position = "none", axis.title = element_blank())



```

# PCA plots
```{r PCA plots}

tmp1 <- ms$rowinfo %>% mutate(color_variable=PMI)
tmp2 <- ms$values

plot_pmi_pca_replicates(tmp1,tmp2, title = "All VH samples, all normalized features", show_legend_title = "PMI")

rm(tmp1, tmp2)
```


# Save normalized selected data
```{r save data}

data <- ms$rowinfo%>%
  cbind(ms$values)

features <- colnames(ms$values)

C_info <- CAMERA_info[, which((names(CAMERA_info) %in% features)== TRUE)]
C_info <- cbind(CAMERA_info[,1:12], C_info)

data <- plyr::rbind.fill(data, C_info)

setwd("...")
write.xlsx(data, "./2_Data normalization/VH/PMI_rat_VH_stable_features_normalized_batchnorm_pos.xlsx")



```




